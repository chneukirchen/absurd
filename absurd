#!/bin/bash
# absurd - build stuff from AUR, ABS or existing directories
#
# Written by Christian Neukirchen <purl.org/net/chneukirchen>, 13jan2013
# 
# To the extent possible under law, the creator of this work has waived
# all copyright and related or neighboring rights to this work.
# http://creativecommons.org/publicdomain/zero/1.0/

# XXX option to install deps from ABS too?
# XXX store git snapshots of $ABSURDTOP before updating?
# XXX --devel
# XXX --noconfirm to makepkg and pacman

[[ -e ~/.absurd.conf ]] && . ~/.absurd.conf

# XXX move to something more persistent later
: ${ABSURDTOP:=/tmp/absurd-$UID}
: ${ABSURDREPO:=/tmp/absurdrepo-$UID/absurd}
: ${ABSURDREPONAME:=$(basename $ABSURDREPO)}
: ${ABSURDJOBS:=1}

: ${ABSURDMAKEPKG:=-s -c}
[[ $UID = 0 ]] && ABSURDMAKEPKG+=" --asroot"

export ABSURDREPONAME

pacman -Sl "$ABSURDREPONAME" >/dev/null 2>&1 || cat <<EOF >/dev/stderr
Warning: repository $ABSURDREPONAME unknown to pacman!
Add these lines to /etc/pacman.conf before any other repo:

  [$ABSURDREPONAME]
  Server = file://$ABSURDREPO

EOF

set -e
mkdir -p "$ABSURDTOP"
mkdir -p "$ABSURDREPO"

cd "$ABSURDTOP"
> .checker

asroot() {
  if [[ $UID = 0 ]]; then
    eval "$@"
  elif type -p sudo >/dev/null && [[ "$ABSURDSUDO" != no ]]; then
    sudo "$@"
  else
    su root -c "$*"
  fi
}

aur_outdated() {
  URL="https://aur.archlinux.org/rpc.php?type=multiinfo"
  for pkg; do URL="$URL&arg[]=$pkg"; done
  curl -Lkgs $URL | jshon -e results -a -e Name -u -p -e Version -u |
    awk '{ORS=NR%2?" ":"\n";print}' |
    sort | join - <(pacman -Q) |
    while read pkg rver lver; do
      (( $(vercmp $rver $lver) > 0 )) && echo $pkg
    done
}

aur_search() {
  curl -Ls "https://aur.archlinux.org/rpc.php?type=search&arg=$1" |
    jshon -e results -a -e Name -u -p         -e Version -u -p   \
                        -e NumVotes -u -p     -e OutOfDate -u -p \
                        -e Description -u |
    awk 'NR%5==0{ORS="\n"}
         NR%5==1{ORS=" ";$1="aur/"$1}
         NR%5==2{ORS=" ("}
         NR%5==3{ORS=") "}
         NR%5==4{$1=$1>0?"OOD":""; ORS="\n  "}
         {print}'
}

installed() {
  pacman -Sl absurd | awk 'NF==4 {print $2}'
}

fetchaur() {
  cd $ABSURDTOP
  [[ -e $1/.keep ]] ||
    curl -Lks https://aur.archlinux.org/packages/${1:0:2}/$1/$1.tar.gz |
    tar xzvf - 2>/dev/null
}

fetchgit() {
  pkg=$1
  cd $ABSURDTOP
  case $(pacman -Spdd --print-format %r $pkg 2>/dev/null || true) in
    core|extra|testing|multilib|multilist-testing)
      git clone --single-branch -b packages/$pkg \
          git://projects.archlinux.org/svntogit/packages.git $pkg;;
    community|community-testing)
      git clone --single-branch -b packages/$pkg \
          git://projects.archlinux.org/svntogit/community.git $pkg;;
    *)
      echo "cannot fetch package $pkg" >/dev/stderr;;
  esac
}

updateaur() {
  for pkg in $(aur_outdated $(pacman -Qmq) $(pacman -Slq absurd)); do
    fetchaur $pkg
  done
}

updategit() {
  cd $ABSURDTOP
  for repo in ${@:-*}; do
    cd $repo/.git/.. || continue
    echo -n ":: updating $(basename $PWD): "
    git pull --no-edit
  done
}

fetch() {
  (( $# )) || set -- $(installed)
  for pkg; do
    [[ -d $ABSURDTOP/$pkg/.git ]] && updategit $pkg ||
      fetchaur $pkg ||
      fetchgit $pkg ||
      true
  done
}

update() {
  updateaur
  updategit
}

# returns non-true if package can/need not be rebuilt
getdeps() {
  pkg=$1
  (
    cd "$ABSURDTOP/$pkg" || return 1

    . /etc/makepkg.conf

    [[ -e trunk/PKGBUILD ]] && cd trunk
    [[ -e PKGBUILD ]] && { . ./PKGBUILD || true; }

    if [[ -z "$pkgname" ]]; then
      echo "cannot find $pkg PKGBUILD" >/dev/stderr
      return
    fi

    echo ${depends[@]} ${makedepends[@]}

    fullver=${epoch:+$epoch:}$pkgver-$pkgrel
    [[ ! ( -f $ABSURDREPO/${pkgname}-${fullver}-${CARCH}${PKGEXT} ||
           -f $ABSURDREPO/${pkgname}-${fullver}-any${PKGEXT} ) ]]
  )
}

depbuild() {
  pkg=$1
  if deps=$(getdeps $1); then
    echo "==> building deps of $pkg" >/dev/stderr
    needed=$(pacman -T $(checker $deps))
    if (( ABSURDJOBS == 1 )); then
      build ${needed[@]}
      pkgbuild $pkg || true
    else
      queue=(${queue[@]} ${needed[@]} !$pkg)
    fi
  else
    true
  fi
}

pkgbuild() {
  pkg=$1
  echo "==> building $pkg" >/dev/stderr
  (
    cd $ABSURDTOP/$pkg
    [[ -e trunk/PKGBUILD ]] && cd trunk
    touch -c PKGBUILD
    PKGDEST=$ABSURDREPO makepkg $ABSURDMAKEPKG &&
    find $ABSURDREPO -newer PKGBUILD -name "*.pkg.*" \
      -exec repo-add $ABSURDREPO/$ABSURDREPONAME.db.tar.gz {} +
  )
}

# don't fetch default repos implicitly, also strip version numbers
checker() {
  [[ -s $ABSURDTOP/.checker ]] ||
    pacman -Sl |
    awk '$1 != ENVIRON["ABSURDREPONAME"] {print $2}' |
    sort -u >$ABSURDTOP/.checker

  comm -23 <(printf '%s\n' "$@" | sed 's/[<>=].*//' |sort -u) \
           $ABSURDTOP/.checker
}

ABSURDIGNORE=()
while (( $# )); do
  case $1 in
    --skipinteg|-A|--ignorearch|-f) ABSURDMAKEPKG+=" $1"; shift;;
    --ignore) shift; ABSURDIGNORE+=(--ignore "$1"); shift;;
    -j*) ABSURDJOBS=${1#-j}; shift;;
    *) break;;
  esac
done

build() {
  for pkg; do depbuild $pkg || true; done

  if (( ABSURDJOBS > 1 )); then
    set -m
    sigchld() {
      joblist=($(jobs -pr))
      (( ${#joblist[@]} > ABSURDJOBS )) && return

      cmd=${queue[0]}; queue=(${queue[@]:1})
      [[ -z "$cmd" ]] && return

      case $cmd in
        !*) pkgbuild ${cmd#!} & ;;
        *) depbuild $cmd ;;
      esac
    }
    trap sigchld CHLD

    for i in $(seq 0 $ABSURDJOBS); do
      sigchld
    done

    wait
  fi
}

case $1 in
  --help|-h|"")
    cat >/dev/stderr <<EOF
usage:  absurd  -S   PKGS...          install from AUR and repos
        absurd  -Sa  PKGS...          install from AUR and ABS
        absurd  -Sw  PKGS...          build packages from AUR and ABS
        absurd  -Su  PKGS...          rebuild all from AUR and ABS
        absurd  -Sy  PKGS...          update from AUR and ABS
        absurd  -Syu PKGS...          update, rebuild and install all packages
        absurd  -Si  PKGS...          display info from AUR and repos
        absurd [-Ss] KEYWORD...       search in AUR and repos

additional options (before -S... only):
        -jN                           run N processes in parallel
        -f                            force rebuilds
        -A, --ignorearch              ignore architecture checks
        --skipinteg                   no verification checks on source files
        --ignore PKGS                 don't operate on comma-seperated PKGS
EOF
    ;;

  -S)
    shift
    (( $# )) || exit 1
    fromaur=($(checker "$@"))
    (( ${#fromaur[@]} )) && fetch "${fromaur[@]}"
    build ${fromaur[@]}
    asroot pacman -Sy
    asroot pacman "${ABSURDIGNORE[@]}" -S "$@"
    ;;

  -Sa)
    # fork from ABS
    (( $# )) || exit 1
    shift
    fetch "$@"
    build "$@"
    asroot pacman -Sy
    asroot pacman "${ABSURDIGNORE[@]}" -S "$@"
    ;;

  -Sw)
    shift
    (( $# )) || exit 0
    fetch "$@"
    build "$@"
    ;;

  -Syu)
    shift
    asroot pacman "${ABSURDIGNORE[@]}" -Syu "$@"
    fetch "$@"
    update
    build $(installed) "$@"
    asroot pacman "${ABSURDIGNORE[@]}" -Syu "$@"
    ;;

  -Sy)
    shift
    update
    asroot pacman "${ABSURDIGNORE[@]}" -Sy
    ;;

  -Su)
    shift
    asroot pacman "${ABSURDIGNORE[@]}" -Su "$@"
    fetch "$@"
    build $(installed)
    asroot pacman "${ABSURDIGNORE[@]}" -Su "$@"
    ;;

  -Q*)
    pacman "$@";;

  -D*|-R*|-U*)
    asroot pacman "$@";;

  -Ss)
    shift ;;&
  *)
    pacman -Ss "$@" || true
    aur_search "$@" || true
    ;;
esac
