#!/bin/bash
# absurd - build stuff from AUR, ABS or existing directories
#
# Written by Christian Neukirchen <purl.org/net/chneukirchen>, 13jan2013
# 
# To the extent possible under law, the creator of this work has waived
# all copyright and related or neighboring rights to this work.
# http://creativecommons.org/publicdomain/zero/1.0/

# XXX option to install deps from ABS too?
# XXX store git snapshots of $ABSURDTOP before updating?
# XXX ability to protect AUR checkouts from being overwritten by cower
# XXX --devel
[[ -e ~/.absurd.conf ]] && . ~/.absurd.conf

# XXX move to something more persistent later
: ${ABSURDTOP:=/tmp/absurd-$UID}
: ${ABSURDREPO:=/tmp/absurdrepo-$UID/absurd}
: ${ABSURDREPONAME:=$(basename $ABSURDREPO)}
: ${ABSURDJOBS:=1}

: ${ABSURDMAKEPKG:=-s -c}
[[ $UID = 0 ]] && ABSURDMAKEPKG+=" --asroot"

export ABSURDREPONAME

pacman -Sl "$ABSURDREPONAME" >/dev/null 2>&1 || cat <<EOF >/dev/stderr
Warning: repository $ABSURDREPONAME unknown to pacman!
Add these lines to /etc/pacman.conf before any other repo:

  [$ABSURDREPONAME]
  Server = file://$ABSURDREPO

EOF

set -e
mkdir -p "$ABSURDTOP"
mkdir -p "$ABSURDREPO"

cd "$ABSURDTOP"
> .checker

asroot() {
  if [[ $UID = 0 ]]; then
    eval "$@"
  elif type -p sudo >/dev/null && [[ "$ABSURDSUDO" != no ]]; then
    sudo "$@"
  else
    su root -c "$*"
  fi
}

installed() {
  pacman -Sl absurd | awk 'NF==4 {print $2}'
}

update() {
  aurpkgs=()
  (( $# )) || set -- $(installed)
  for pkg; do
    if [[ -d "$pkg/.git" ]]; then
      ( cd "$pkg"; echo -n ":: updating $pkg: "; git pull --no-edit )
    else
      aurpkgs+=($pkg)
    fi
  done
  (( ${#aurpkgs[@]} )) && cower --ignorerepo=$ABSURDREPONAME -f -d ${aurpkgs[@]} || true
}

fetch() {
  (( $# )) || set -- $(installed)
  cower --ignorerepo=$ABSURDREPONAME -f -d "$@" || true
  for pkg; do
    if [[ -d "$pkg/.git" ]]; then
      update "$pkg"
      continue
    fi

    [[ -d "$pkg" ]] ||
      case $(pacman -Spdd --print-format %r $pkg 2>/dev/null || true) in
        core|extra|testing|multilib|multilist-testing)
          git clone --single-branch -b packages/$pkg \
              git://projects.archlinux.org/svntogit/packages.git $pkg;;
        community|community-testing)
          git clone --single-branch -b packages/$pkg \
              git://projects.archlinux.org/svntogit/community.git $pkg;;
        *)
          echo "cannot fetch package $pkg" >/dev/stderr;;
      esac
  done
}

# returns non-true if package can/need not be rebuilt
getdeps() {
  pkg=$1
  (
    cd "$ABSURDTOP/$pkg" || return 1

    . /etc/makepkg.conf

    [[ -e trunk/PKGBUILD ]] && cd trunk
    [[ -e PKGBUILD ]] && { . ./PKGBUILD || true; }

    if [[ -z "$pkgname" ]]; then
      echo "cannot find $pkg PKGBUILD" >/dev/stderr
      return
    fi

    echo ${depends[@]} ${makedepends[@]}

    fullver=${epoch:+$epoch:}$pkgver-$pkgrel
    [[ ! ( -f $ABSURDREPO/${pkgname}-${fullver}-${CARCH}${PKGEXT} ||
           -f $ABSURDREPO/${pkgname}-${fullver}-any${PKGEXT} ) ]]
  )
}

depbuild() {
  pkg=$1
  if deps=$(getdeps $1); then
    echo "==> building deps of $pkg" >/dev/stderr
    if (( ABSURDJOBS == 1 )); then
      build $(checker $deps)
      pkgbuild $pkg || true
    else
      queue=(${queue[@]} $(checker $deps) !$pkg)
    fi
  fi
}

pkgbuild() {
  pkg=$1
  echo "==> building $pkg" >/dev/stderr
  (
    cd $ABSURDTOP/$pkg
    [[ -e trunk/PKGBUILD ]] && cd trunk
    touch -c PKGBUILD
    PKGDEST=$ABSURDREPO makepkg $ABSURDMAKEPKG &&
    find $ABSURDREPO -newer PKGBUILD -name "*.pkg.*" \
      -exec repo-add $ABSURDREPO/$ABSURDREPONAME.db.tar.gz {} +
  )
}

# don't fetch default repos implicitly, also strip version numbers
checker() {
  [ -s $ABSURDTOP/.checker ] ||
    pacman -Sl |
    awk '$1 != ENVIRON["ABSURDREPONAME"] {print $2}' |
    sort -u >$ABSURDTOP/.checker

  comm -23 <(printf '%s\n' "$@" | sed 's/[<>=].*//' |sort -u) \
           $ABSURDTOP/.checker
}

ABSURDIGNORE=()
while (( $# )); do
  case $1 in
    --skipinteg|-A|--ignorearch|-f) ABSURDMAKEPKG+=" $1"; shift;;
    --ignore) shift; ABSURDIGNORE+=(--ignore "$1"); shift;;
    -j*) ABSURDJOBS=${1#-j}; shift;;
    *) break;;
  esac
done

build() {
  for pkg; do depbuild $pkg; done

  if (( ABSURDJOBS > 1 )); then
    set -m
    sigchld() {
      joblist=($(jobs -pr))
      (( ${#joblist[@]} > ABSURDJOBS )) && return

      cmd=${queue[0]}; queue=(${queue[@]:1})
      [[ -z "$cmd" ]] && return

      case $cmd in
        !*) pkgbuild ${cmd#!} & ;;
        *) depbuild $cmd ;;
      esac
    }
    trap sigchld CHLD

    for i in $(seq 0 $ABSURDJOBS); do
      sigchld
    done

    wait
  fi
}

case $1 in
  --help|-h|"")
    cat >/dev/stderr <<EOF
usage:  absurd  -S   PKGS...          install from AUR and repos
        absurd  -Sa  PKGS...          install from AUR and ABS
        absurd  -Sw  PKGS...          build packages from AUR and ABS
        absurd  -Su  PKGS...          rebuild all from AUR and ABS
        absurd  -Sy  PKGS...          update from AUR and ABS
        absurd  -Syu PKGS...          update, rebuild and install all packages
        absurd  -Si  PKGS...          display info from AUR and repos
        absurd [-Ss] KEYWORD...       search in AUR and repos

additional options (before -S... only):
        -jN                           run N processes in parallel
        -f                            force rebuilds
        -A, --ignorearch              ignore architecture checks
        --skipinteg                   no verification checks on source files
        --ignore PKGS                 don't operate on comma-seperated PKGS
EOF
    ;;

  -S)
    shift
    fromaur=($(checker "$@"))
    (( ${#fromaur[@]} )) && fetch "${fromaur[@]}"
    build ${fromaur[@]}
    asroot pacman "${ABSURDIGNORE[@]}" -S "$@"
    ;;

  -Sa)
    # fork from ABS
    shift
    (( $# )) || set -- $(installed)
    fetch "$@"
    build "$@"
    asroot pacman "${ABSURDIGNORE[@]}" -S "$@"
    ;;

  -Sw)
    shift
    (( $# )) || exit 0
    fetch "$@"
    build "$@"
    ;;

  -Syu)
    shift
    asroot pacman "${ABSURDIGNORE[@]}" -Syu "$@"
    fetch "$@"
    update
    build $(installed) "$@"
    asroot pacman "${ABSURDIGNORE[@]}" -Syu "$@"
    ;;

  -Sy)
    shift
    update "$@"
    asroot pacman "${ABSURDIGNORE[@]}" -Sy
    ;;

  -Su)
    shift
    asroot pacman "${ABSURDIGNORE[@]}" -Su "$@"
    fetch "$@"
    build $(installed)
    asroot pacman "${ABSURDIGNORE[@]}" -Su "$@"
    ;;

  -Si)
    shift
    pacman -Si "$@" 2>/dev/null || true
    cower -i "$@" 2>/dev/null || true
    ;;

  -Q*)
    pacman "$@";;

  -D*|-R*|-U*)
    asroot pacman "$@";;

  -Ss)
    shift ;;&
  *)
    pacman -Ss "$@" || true
    cower -s "$@" || true
    ;;
esac
